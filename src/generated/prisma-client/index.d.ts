// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  ankieta: (where?: AnkietaWhereInput) => Promise<boolean>;
  odpowiedz: (where?: OdpowiedzWhereInput) => Promise<boolean>;
  odpowiedzi: (where?: OdpowiedziWhereInput) => Promise<boolean>;
  pytanie: (where?: PytanieWhereInput) => Promise<boolean>;
  uzytkownik: (where?: UzytkownikWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  ankieta: (where: AnkietaWhereUniqueInput) => AnkietaNullablePromise;
  ankietas: (args?: {
    where?: AnkietaWhereInput;
    orderBy?: AnkietaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ankieta>;
  ankietasConnection: (args?: {
    where?: AnkietaWhereInput;
    orderBy?: AnkietaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnkietaConnectionPromise;
  odpowiedz: (where: OdpowiedzWhereUniqueInput) => OdpowiedzNullablePromise;
  odpowiedzes: (args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Odpowiedz>;
  odpowiedzesConnection: (args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OdpowiedzConnectionPromise;
  odpowiedzi: (where: OdpowiedziWhereUniqueInput) => OdpowiedziNullablePromise;
  odpowiedzis: (args?: {
    where?: OdpowiedziWhereInput;
    orderBy?: OdpowiedziOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Odpowiedzi>;
  odpowiedzisConnection: (args?: {
    where?: OdpowiedziWhereInput;
    orderBy?: OdpowiedziOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OdpowiedziConnectionPromise;
  pytanie: (where: PytanieWhereUniqueInput) => PytanieNullablePromise;
  pytanies: (args?: {
    where?: PytanieWhereInput;
    orderBy?: PytanieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Pytanie>;
  pytaniesConnection: (args?: {
    where?: PytanieWhereInput;
    orderBy?: PytanieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PytanieConnectionPromise;
  uzytkownik: (where: UzytkownikWhereUniqueInput) => UzytkownikNullablePromise;
  uzytkowniks: (args?: {
    where?: UzytkownikWhereInput;
    orderBy?: UzytkownikOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Uzytkownik>;
  uzytkowniksConnection: (args?: {
    where?: UzytkownikWhereInput;
    orderBy?: UzytkownikOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UzytkownikConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAnkieta: (data: AnkietaCreateInput) => AnkietaPromise;
  updateAnkieta: (args: {
    data: AnkietaUpdateInput;
    where: AnkietaWhereUniqueInput;
  }) => AnkietaPromise;
  updateManyAnkietas: (args: {
    data: AnkietaUpdateManyMutationInput;
    where?: AnkietaWhereInput;
  }) => BatchPayloadPromise;
  upsertAnkieta: (args: {
    where: AnkietaWhereUniqueInput;
    create: AnkietaCreateInput;
    update: AnkietaUpdateInput;
  }) => AnkietaPromise;
  deleteAnkieta: (where: AnkietaWhereUniqueInput) => AnkietaPromise;
  deleteManyAnkietas: (where?: AnkietaWhereInput) => BatchPayloadPromise;
  createOdpowiedz: (data: OdpowiedzCreateInput) => OdpowiedzPromise;
  updateOdpowiedz: (args: {
    data: OdpowiedzUpdateInput;
    where: OdpowiedzWhereUniqueInput;
  }) => OdpowiedzPromise;
  updateManyOdpowiedzes: (args: {
    data: OdpowiedzUpdateManyMutationInput;
    where?: OdpowiedzWhereInput;
  }) => BatchPayloadPromise;
  upsertOdpowiedz: (args: {
    where: OdpowiedzWhereUniqueInput;
    create: OdpowiedzCreateInput;
    update: OdpowiedzUpdateInput;
  }) => OdpowiedzPromise;
  deleteOdpowiedz: (where: OdpowiedzWhereUniqueInput) => OdpowiedzPromise;
  deleteManyOdpowiedzes: (where?: OdpowiedzWhereInput) => BatchPayloadPromise;
  createOdpowiedzi: (data: OdpowiedziCreateInput) => OdpowiedziPromise;
  updateOdpowiedzi: (args: {
    data: OdpowiedziUpdateInput;
    where: OdpowiedziWhereUniqueInput;
  }) => OdpowiedziPromise;
  updateManyOdpowiedzis: (args: {
    data: OdpowiedziUpdateManyMutationInput;
    where?: OdpowiedziWhereInput;
  }) => BatchPayloadPromise;
  upsertOdpowiedzi: (args: {
    where: OdpowiedziWhereUniqueInput;
    create: OdpowiedziCreateInput;
    update: OdpowiedziUpdateInput;
  }) => OdpowiedziPromise;
  deleteOdpowiedzi: (where: OdpowiedziWhereUniqueInput) => OdpowiedziPromise;
  deleteManyOdpowiedzis: (where?: OdpowiedziWhereInput) => BatchPayloadPromise;
  createPytanie: (data: PytanieCreateInput) => PytaniePromise;
  updatePytanie: (args: {
    data: PytanieUpdateInput;
    where: PytanieWhereUniqueInput;
  }) => PytaniePromise;
  updateManyPytanies: (args: {
    data: PytanieUpdateManyMutationInput;
    where?: PytanieWhereInput;
  }) => BatchPayloadPromise;
  upsertPytanie: (args: {
    where: PytanieWhereUniqueInput;
    create: PytanieCreateInput;
    update: PytanieUpdateInput;
  }) => PytaniePromise;
  deletePytanie: (where: PytanieWhereUniqueInput) => PytaniePromise;
  deleteManyPytanies: (where?: PytanieWhereInput) => BatchPayloadPromise;
  createUzytkownik: (data: UzytkownikCreateInput) => UzytkownikPromise;
  updateUzytkownik: (args: {
    data: UzytkownikUpdateInput;
    where: UzytkownikWhereUniqueInput;
  }) => UzytkownikPromise;
  updateManyUzytkowniks: (args: {
    data: UzytkownikUpdateManyMutationInput;
    where?: UzytkownikWhereInput;
  }) => BatchPayloadPromise;
  upsertUzytkownik: (args: {
    where: UzytkownikWhereUniqueInput;
    create: UzytkownikCreateInput;
    update: UzytkownikUpdateInput;
  }) => UzytkownikPromise;
  deleteUzytkownik: (where: UzytkownikWhereUniqueInput) => UzytkownikPromise;
  deleteManyUzytkowniks: (where?: UzytkownikWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  ankieta: (
    where?: AnkietaSubscriptionWhereInput
  ) => AnkietaSubscriptionPayloadSubscription;
  odpowiedz: (
    where?: OdpowiedzSubscriptionWhereInput
  ) => OdpowiedzSubscriptionPayloadSubscription;
  odpowiedzi: (
    where?: OdpowiedziSubscriptionWhereInput
  ) => OdpowiedziSubscriptionPayloadSubscription;
  pytanie: (
    where?: PytanieSubscriptionWhereInput
  ) => PytanieSubscriptionPayloadSubscription;
  uzytkownik: (
    where?: UzytkownikSubscriptionWhereInput
  ) => UzytkownikSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PytanieOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "numerPytania_ASC"
  | "numerPytania_DESC"
  | "trescPytnia_ASC"
  | "trescPytnia_DESC"
  | "pytanieKontrolne_ASC"
  | "pytanieKontrolne_DESC"
  | "reprezentacjaPytania_ASC"
  | "reprezentacjaPytania_DESC";

export type OdpowiedzOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nrOdpowiedzi_ASC"
  | "nrOdpowiedzi_DESC"
  | "odpowiedz_ASC"
  | "odpowiedz_DESC";

export type AnkietaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nazwaAnkiety_ASC"
  | "nazwaAnkiety_DESC"
  | "czasZakonczenia_ASC"
  | "czasZakonczenia_DESC";

export type OdpowiedziOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "idAnkiety_ASC"
  | "idAnkiety_DESC"
  | "pseudonim_ASC"
  | "pseudonim_DESC";

export type UzytkownikOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "login_ASC"
  | "login_DESC"
  | "haslo_ASC"
  | "haslo_DESC"
  | "token_ASC"
  | "token_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface OdpowiedzCreateManyInput {
  create?: Maybe<OdpowiedzCreateInput[] | OdpowiedzCreateInput>;
  connect?: Maybe<OdpowiedzWhereUniqueInput[] | OdpowiedzWhereUniqueInput>;
}

export type AnkietaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PytanieUpdateManyWithWhereNestedInput {
  where: PytanieScalarWhereInput;
  data: PytanieUpdateManyDataInput;
}

export interface OdpowiedzUpdateWithWhereUniqueNestedInput {
  where: OdpowiedzWhereUniqueInput;
  data: OdpowiedzUpdateDataInput;
}

export interface PytanieScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  numerPytania?: Maybe<Int>;
  numerPytania_not?: Maybe<Int>;
  numerPytania_in?: Maybe<Int[] | Int>;
  numerPytania_not_in?: Maybe<Int[] | Int>;
  numerPytania_lt?: Maybe<Int>;
  numerPytania_lte?: Maybe<Int>;
  numerPytania_gt?: Maybe<Int>;
  numerPytania_gte?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  trescPytnia_not?: Maybe<String>;
  trescPytnia_in?: Maybe<String[] | String>;
  trescPytnia_not_in?: Maybe<String[] | String>;
  trescPytnia_lt?: Maybe<String>;
  trescPytnia_lte?: Maybe<String>;
  trescPytnia_gt?: Maybe<String>;
  trescPytnia_gte?: Maybe<String>;
  trescPytnia_contains?: Maybe<String>;
  trescPytnia_not_contains?: Maybe<String>;
  trescPytnia_starts_with?: Maybe<String>;
  trescPytnia_not_starts_with?: Maybe<String>;
  trescPytnia_ends_with?: Maybe<String>;
  trescPytnia_not_ends_with?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  pytanieKontrolne_not?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
  reprezentacjaPytania_not?: Maybe<String>;
  reprezentacjaPytania_in?: Maybe<String[] | String>;
  reprezentacjaPytania_not_in?: Maybe<String[] | String>;
  reprezentacjaPytania_lt?: Maybe<String>;
  reprezentacjaPytania_lte?: Maybe<String>;
  reprezentacjaPytania_gt?: Maybe<String>;
  reprezentacjaPytania_gte?: Maybe<String>;
  reprezentacjaPytania_contains?: Maybe<String>;
  reprezentacjaPytania_not_contains?: Maybe<String>;
  reprezentacjaPytania_starts_with?: Maybe<String>;
  reprezentacjaPytania_not_starts_with?: Maybe<String>;
  reprezentacjaPytania_ends_with?: Maybe<String>;
  reprezentacjaPytania_not_ends_with?: Maybe<String>;
  AND?: Maybe<PytanieScalarWhereInput[] | PytanieScalarWhereInput>;
  OR?: Maybe<PytanieScalarWhereInput[] | PytanieScalarWhereInput>;
  NOT?: Maybe<PytanieScalarWhereInput[] | PytanieScalarWhereInput>;
}

export interface UzytkownikUpdateDataInput {
  login?: Maybe<String>;
  haslo?: Maybe<String>;
  token?: Maybe<String>;
}

export interface PytanieUpsertWithWhereUniqueNestedInput {
  where: PytanieWhereUniqueInput;
  update: PytanieUpdateDataInput;
  create: PytanieCreateInput;
}

export interface PytanieSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PytanieWhereInput>;
  AND?: Maybe<PytanieSubscriptionWhereInput[] | PytanieSubscriptionWhereInput>;
  OR?: Maybe<PytanieSubscriptionWhereInput[] | PytanieSubscriptionWhereInput>;
  NOT?: Maybe<PytanieSubscriptionWhereInput[] | PytanieSubscriptionWhereInput>;
}

export type UzytkownikWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  login?: Maybe<String>;
}>;

export interface OdpowiedziSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OdpowiedziWhereInput>;
  AND?: Maybe<
    OdpowiedziSubscriptionWhereInput[] | OdpowiedziSubscriptionWhereInput
  >;
  OR?: Maybe<
    OdpowiedziSubscriptionWhereInput[] | OdpowiedziSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OdpowiedziSubscriptionWhereInput[] | OdpowiedziSubscriptionWhereInput
  >;
}

export interface OdpowiedzUpdateManyDataInput {
  nrOdpowiedzi?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
}

export interface UzytkownikWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  login?: Maybe<String>;
  login_not?: Maybe<String>;
  login_in?: Maybe<String[] | String>;
  login_not_in?: Maybe<String[] | String>;
  login_lt?: Maybe<String>;
  login_lte?: Maybe<String>;
  login_gt?: Maybe<String>;
  login_gte?: Maybe<String>;
  login_contains?: Maybe<String>;
  login_not_contains?: Maybe<String>;
  login_starts_with?: Maybe<String>;
  login_not_starts_with?: Maybe<String>;
  login_ends_with?: Maybe<String>;
  login_not_ends_with?: Maybe<String>;
  haslo?: Maybe<String>;
  haslo_not?: Maybe<String>;
  haslo_in?: Maybe<String[] | String>;
  haslo_not_in?: Maybe<String[] | String>;
  haslo_lt?: Maybe<String>;
  haslo_lte?: Maybe<String>;
  haslo_gt?: Maybe<String>;
  haslo_gte?: Maybe<String>;
  haslo_contains?: Maybe<String>;
  haslo_not_contains?: Maybe<String>;
  haslo_starts_with?: Maybe<String>;
  haslo_not_starts_with?: Maybe<String>;
  haslo_ends_with?: Maybe<String>;
  haslo_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  AND?: Maybe<UzytkownikWhereInput[] | UzytkownikWhereInput>;
  OR?: Maybe<UzytkownikWhereInput[] | UzytkownikWhereInput>;
  NOT?: Maybe<UzytkownikWhereInput[] | UzytkownikWhereInput>;
}

export interface OdpowiedzUpdateManyWithWhereNestedInput {
  where: OdpowiedzScalarWhereInput;
  data: OdpowiedzUpdateManyDataInput;
}

export interface AnkietaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnkietaWhereInput>;
  AND?: Maybe<AnkietaSubscriptionWhereInput[] | AnkietaSubscriptionWhereInput>;
  OR?: Maybe<AnkietaSubscriptionWhereInput[] | AnkietaSubscriptionWhereInput>;
  NOT?: Maybe<AnkietaSubscriptionWhereInput[] | AnkietaSubscriptionWhereInput>;
}

export interface OdpowiedzScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nrOdpowiedzi?: Maybe<Int>;
  nrOdpowiedzi_not?: Maybe<Int>;
  nrOdpowiedzi_in?: Maybe<Int[] | Int>;
  nrOdpowiedzi_not_in?: Maybe<Int[] | Int>;
  nrOdpowiedzi_lt?: Maybe<Int>;
  nrOdpowiedzi_lte?: Maybe<Int>;
  nrOdpowiedzi_gt?: Maybe<Int>;
  nrOdpowiedzi_gte?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
  odpowiedz_not?: Maybe<String>;
  odpowiedz_in?: Maybe<String[] | String>;
  odpowiedz_not_in?: Maybe<String[] | String>;
  odpowiedz_lt?: Maybe<String>;
  odpowiedz_lte?: Maybe<String>;
  odpowiedz_gt?: Maybe<String>;
  odpowiedz_gte?: Maybe<String>;
  odpowiedz_contains?: Maybe<String>;
  odpowiedz_not_contains?: Maybe<String>;
  odpowiedz_starts_with?: Maybe<String>;
  odpowiedz_not_starts_with?: Maybe<String>;
  odpowiedz_ends_with?: Maybe<String>;
  odpowiedz_not_ends_with?: Maybe<String>;
  AND?: Maybe<OdpowiedzScalarWhereInput[] | OdpowiedzScalarWhereInput>;
  OR?: Maybe<OdpowiedzScalarWhereInput[] | OdpowiedzScalarWhereInput>;
  NOT?: Maybe<OdpowiedzScalarWhereInput[] | OdpowiedzScalarWhereInput>;
}

export interface UzytkownikUpdateInput {
  login?: Maybe<String>;
  haslo?: Maybe<String>;
  token?: Maybe<String>;
}

export interface OdpowiedzUpsertWithWhereUniqueNestedInput {
  where: OdpowiedzWhereUniqueInput;
  update: OdpowiedzUpdateDataInput;
  create: OdpowiedzCreateInput;
}

export type OdpowiedzWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OdpowiedziUpdateManyMutationInput {
  idAnkiety?: Maybe<ID_Input>;
  pseudonim?: Maybe<String>;
}

export type OdpowiedziWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AnkietaCreateInput {
  id?: Maybe<ID_Input>;
  nazwaAnkiety: String;
  tworca: UzytkownikCreateOneInput;
  czasZakonczenia: DateTimeInput;
  pytania?: Maybe<PytanieCreateManyInput>;
}

export interface OdpowiedziWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  idAnkiety?: Maybe<ID_Input>;
  idAnkiety_not?: Maybe<ID_Input>;
  idAnkiety_in?: Maybe<ID_Input[] | ID_Input>;
  idAnkiety_not_in?: Maybe<ID_Input[] | ID_Input>;
  idAnkiety_lt?: Maybe<ID_Input>;
  idAnkiety_lte?: Maybe<ID_Input>;
  idAnkiety_gt?: Maybe<ID_Input>;
  idAnkiety_gte?: Maybe<ID_Input>;
  idAnkiety_contains?: Maybe<ID_Input>;
  idAnkiety_not_contains?: Maybe<ID_Input>;
  idAnkiety_starts_with?: Maybe<ID_Input>;
  idAnkiety_not_starts_with?: Maybe<ID_Input>;
  idAnkiety_ends_with?: Maybe<ID_Input>;
  idAnkiety_not_ends_with?: Maybe<ID_Input>;
  pseudonim?: Maybe<String>;
  pseudonim_not?: Maybe<String>;
  pseudonim_in?: Maybe<String[] | String>;
  pseudonim_not_in?: Maybe<String[] | String>;
  pseudonim_lt?: Maybe<String>;
  pseudonim_lte?: Maybe<String>;
  pseudonim_gt?: Maybe<String>;
  pseudonim_gte?: Maybe<String>;
  pseudonim_contains?: Maybe<String>;
  pseudonim_not_contains?: Maybe<String>;
  pseudonim_starts_with?: Maybe<String>;
  pseudonim_not_starts_with?: Maybe<String>;
  pseudonim_ends_with?: Maybe<String>;
  pseudonim_not_ends_with?: Maybe<String>;
  odpowiedzi_every?: Maybe<OdpowiedzWhereInput>;
  odpowiedzi_some?: Maybe<OdpowiedzWhereInput>;
  odpowiedzi_none?: Maybe<OdpowiedzWhereInput>;
  AND?: Maybe<OdpowiedziWhereInput[] | OdpowiedziWhereInput>;
  OR?: Maybe<OdpowiedziWhereInput[] | OdpowiedziWhereInput>;
  NOT?: Maybe<OdpowiedziWhereInput[] | OdpowiedziWhereInput>;
}

export interface UzytkownikCreateOneInput {
  create?: Maybe<UzytkownikCreateInput>;
  connect?: Maybe<UzytkownikWhereUniqueInput>;
}

export interface OdpowiedzUpdateInput {
  nrOdpowiedzi?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
}

export interface UzytkownikCreateInput {
  id?: Maybe<ID_Input>;
  login: String;
  haslo: String;
  token: String;
}

export interface PytanieUpdateManyDataInput {
  numerPytania?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
}

export interface PytanieCreateManyInput {
  create?: Maybe<PytanieCreateInput[] | PytanieCreateInput>;
  connect?: Maybe<PytanieWhereUniqueInput[] | PytanieWhereUniqueInput>;
}

export interface UzytkownikSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UzytkownikWhereInput>;
  AND?: Maybe<
    UzytkownikSubscriptionWhereInput[] | UzytkownikSubscriptionWhereInput
  >;
  OR?: Maybe<
    UzytkownikSubscriptionWhereInput[] | UzytkownikSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UzytkownikSubscriptionWhereInput[] | UzytkownikSubscriptionWhereInput
  >;
}

export interface PytanieCreateInput {
  id?: Maybe<ID_Input>;
  numerPytania: Int;
  trescPytnia: String;
  pytanieKontrolne: Boolean;
  reprezentacjaPytania: String;
  odpowiedzi?: Maybe<OdpowiedzCreateManyInput>;
}

export interface AnkietaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nazwaAnkiety?: Maybe<String>;
  nazwaAnkiety_not?: Maybe<String>;
  nazwaAnkiety_in?: Maybe<String[] | String>;
  nazwaAnkiety_not_in?: Maybe<String[] | String>;
  nazwaAnkiety_lt?: Maybe<String>;
  nazwaAnkiety_lte?: Maybe<String>;
  nazwaAnkiety_gt?: Maybe<String>;
  nazwaAnkiety_gte?: Maybe<String>;
  nazwaAnkiety_contains?: Maybe<String>;
  nazwaAnkiety_not_contains?: Maybe<String>;
  nazwaAnkiety_starts_with?: Maybe<String>;
  nazwaAnkiety_not_starts_with?: Maybe<String>;
  nazwaAnkiety_ends_with?: Maybe<String>;
  nazwaAnkiety_not_ends_with?: Maybe<String>;
  tworca?: Maybe<UzytkownikWhereInput>;
  czasZakonczenia?: Maybe<DateTimeInput>;
  czasZakonczenia_not?: Maybe<DateTimeInput>;
  czasZakonczenia_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  czasZakonczenia_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  czasZakonczenia_lt?: Maybe<DateTimeInput>;
  czasZakonczenia_lte?: Maybe<DateTimeInput>;
  czasZakonczenia_gt?: Maybe<DateTimeInput>;
  czasZakonczenia_gte?: Maybe<DateTimeInput>;
  pytania_every?: Maybe<PytanieWhereInput>;
  pytania_some?: Maybe<PytanieWhereInput>;
  pytania_none?: Maybe<PytanieWhereInput>;
  AND?: Maybe<AnkietaWhereInput[] | AnkietaWhereInput>;
  OR?: Maybe<AnkietaWhereInput[] | AnkietaWhereInput>;
  NOT?: Maybe<AnkietaWhereInput[] | AnkietaWhereInput>;
}

export interface OdpowiedzUpdateDataInput {
  nrOdpowiedzi?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
}

export interface UzytkownikUpdateManyMutationInput {
  login?: Maybe<String>;
  haslo?: Maybe<String>;
  token?: Maybe<String>;
}

export interface OdpowiedzCreateInput {
  id?: Maybe<ID_Input>;
  nrOdpowiedzi: Int;
  odpowiedz: String;
}

export interface PytanieUpdateInput {
  numerPytania?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
  odpowiedzi?: Maybe<OdpowiedzUpdateManyInput>;
}

export interface AnkietaUpdateInput {
  nazwaAnkiety?: Maybe<String>;
  tworca?: Maybe<UzytkownikUpdateOneRequiredInput>;
  czasZakonczenia?: Maybe<DateTimeInput>;
  pytania?: Maybe<PytanieUpdateManyInput>;
}

export interface OdpowiedziCreateInput {
  id?: Maybe<ID_Input>;
  idAnkiety: ID_Input;
  pseudonim: String;
  odpowiedzi?: Maybe<OdpowiedzCreateManyInput>;
}

export interface UzytkownikUpdateOneRequiredInput {
  create?: Maybe<UzytkownikCreateInput>;
  update?: Maybe<UzytkownikUpdateDataInput>;
  upsert?: Maybe<UzytkownikUpsertNestedInput>;
  connect?: Maybe<UzytkownikWhereUniqueInput>;
}

export interface AnkietaUpdateManyMutationInput {
  nazwaAnkiety?: Maybe<String>;
  czasZakonczenia?: Maybe<DateTimeInput>;
}

export interface OdpowiedzWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nrOdpowiedzi?: Maybe<Int>;
  nrOdpowiedzi_not?: Maybe<Int>;
  nrOdpowiedzi_in?: Maybe<Int[] | Int>;
  nrOdpowiedzi_not_in?: Maybe<Int[] | Int>;
  nrOdpowiedzi_lt?: Maybe<Int>;
  nrOdpowiedzi_lte?: Maybe<Int>;
  nrOdpowiedzi_gt?: Maybe<Int>;
  nrOdpowiedzi_gte?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
  odpowiedz_not?: Maybe<String>;
  odpowiedz_in?: Maybe<String[] | String>;
  odpowiedz_not_in?: Maybe<String[] | String>;
  odpowiedz_lt?: Maybe<String>;
  odpowiedz_lte?: Maybe<String>;
  odpowiedz_gt?: Maybe<String>;
  odpowiedz_gte?: Maybe<String>;
  odpowiedz_contains?: Maybe<String>;
  odpowiedz_not_contains?: Maybe<String>;
  odpowiedz_starts_with?: Maybe<String>;
  odpowiedz_not_starts_with?: Maybe<String>;
  odpowiedz_ends_with?: Maybe<String>;
  odpowiedz_not_ends_with?: Maybe<String>;
  AND?: Maybe<OdpowiedzWhereInput[] | OdpowiedzWhereInput>;
  OR?: Maybe<OdpowiedzWhereInput[] | OdpowiedzWhereInput>;
  NOT?: Maybe<OdpowiedzWhereInput[] | OdpowiedzWhereInput>;
}

export interface PytanieWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  numerPytania?: Maybe<Int>;
  numerPytania_not?: Maybe<Int>;
  numerPytania_in?: Maybe<Int[] | Int>;
  numerPytania_not_in?: Maybe<Int[] | Int>;
  numerPytania_lt?: Maybe<Int>;
  numerPytania_lte?: Maybe<Int>;
  numerPytania_gt?: Maybe<Int>;
  numerPytania_gte?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  trescPytnia_not?: Maybe<String>;
  trescPytnia_in?: Maybe<String[] | String>;
  trescPytnia_not_in?: Maybe<String[] | String>;
  trescPytnia_lt?: Maybe<String>;
  trescPytnia_lte?: Maybe<String>;
  trescPytnia_gt?: Maybe<String>;
  trescPytnia_gte?: Maybe<String>;
  trescPytnia_contains?: Maybe<String>;
  trescPytnia_not_contains?: Maybe<String>;
  trescPytnia_starts_with?: Maybe<String>;
  trescPytnia_not_starts_with?: Maybe<String>;
  trescPytnia_ends_with?: Maybe<String>;
  trescPytnia_not_ends_with?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  pytanieKontrolne_not?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
  reprezentacjaPytania_not?: Maybe<String>;
  reprezentacjaPytania_in?: Maybe<String[] | String>;
  reprezentacjaPytania_not_in?: Maybe<String[] | String>;
  reprezentacjaPytania_lt?: Maybe<String>;
  reprezentacjaPytania_lte?: Maybe<String>;
  reprezentacjaPytania_gt?: Maybe<String>;
  reprezentacjaPytania_gte?: Maybe<String>;
  reprezentacjaPytania_contains?: Maybe<String>;
  reprezentacjaPytania_not_contains?: Maybe<String>;
  reprezentacjaPytania_starts_with?: Maybe<String>;
  reprezentacjaPytania_not_starts_with?: Maybe<String>;
  reprezentacjaPytania_ends_with?: Maybe<String>;
  reprezentacjaPytania_not_ends_with?: Maybe<String>;
  odpowiedzi_every?: Maybe<OdpowiedzWhereInput>;
  odpowiedzi_some?: Maybe<OdpowiedzWhereInput>;
  odpowiedzi_none?: Maybe<OdpowiedzWhereInput>;
  AND?: Maybe<PytanieWhereInput[] | PytanieWhereInput>;
  OR?: Maybe<PytanieWhereInput[] | PytanieWhereInput>;
  NOT?: Maybe<PytanieWhereInput[] | PytanieWhereInput>;
}

export interface UzytkownikUpsertNestedInput {
  update: UzytkownikUpdateDataInput;
  create: UzytkownikCreateInput;
}

export interface PytanieUpdateManyMutationInput {
  numerPytania?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
}

export interface OdpowiedzUpdateManyInput {
  create?: Maybe<OdpowiedzCreateInput[] | OdpowiedzCreateInput>;
  update?: Maybe<
    | OdpowiedzUpdateWithWhereUniqueNestedInput[]
    | OdpowiedzUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OdpowiedzUpsertWithWhereUniqueNestedInput[]
    | OdpowiedzUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<OdpowiedzWhereUniqueInput[] | OdpowiedzWhereUniqueInput>;
  connect?: Maybe<OdpowiedzWhereUniqueInput[] | OdpowiedzWhereUniqueInput>;
  set?: Maybe<OdpowiedzWhereUniqueInput[] | OdpowiedzWhereUniqueInput>;
  disconnect?: Maybe<OdpowiedzWhereUniqueInput[] | OdpowiedzWhereUniqueInput>;
  deleteMany?: Maybe<OdpowiedzScalarWhereInput[] | OdpowiedzScalarWhereInput>;
  updateMany?: Maybe<
    | OdpowiedzUpdateManyWithWhereNestedInput[]
    | OdpowiedzUpdateManyWithWhereNestedInput
  >;
}

export interface PytanieUpdateDataInput {
  numerPytania?: Maybe<Int>;
  trescPytnia?: Maybe<String>;
  pytanieKontrolne?: Maybe<Boolean>;
  reprezentacjaPytania?: Maybe<String>;
  odpowiedzi?: Maybe<OdpowiedzUpdateManyInput>;
}

export interface PytanieUpdateWithWhereUniqueNestedInput {
  where: PytanieWhereUniqueInput;
  data: PytanieUpdateDataInput;
}

export interface PytanieUpdateManyInput {
  create?: Maybe<PytanieCreateInput[] | PytanieCreateInput>;
  update?: Maybe<
    | PytanieUpdateWithWhereUniqueNestedInput[]
    | PytanieUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PytanieUpsertWithWhereUniqueNestedInput[]
    | PytanieUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PytanieWhereUniqueInput[] | PytanieWhereUniqueInput>;
  connect?: Maybe<PytanieWhereUniqueInput[] | PytanieWhereUniqueInput>;
  set?: Maybe<PytanieWhereUniqueInput[] | PytanieWhereUniqueInput>;
  disconnect?: Maybe<PytanieWhereUniqueInput[] | PytanieWhereUniqueInput>;
  deleteMany?: Maybe<PytanieScalarWhereInput[] | PytanieScalarWhereInput>;
  updateMany?: Maybe<
    | PytanieUpdateManyWithWhereNestedInput[]
    | PytanieUpdateManyWithWhereNestedInput
  >;
}

export interface OdpowiedziUpdateInput {
  idAnkiety?: Maybe<ID_Input>;
  pseudonim?: Maybe<String>;
  odpowiedzi?: Maybe<OdpowiedzUpdateManyInput>;
}

export interface OdpowiedzSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OdpowiedzWhereInput>;
  AND?: Maybe<
    OdpowiedzSubscriptionWhereInput[] | OdpowiedzSubscriptionWhereInput
  >;
  OR?: Maybe<
    OdpowiedzSubscriptionWhereInput[] | OdpowiedzSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OdpowiedzSubscriptionWhereInput[] | OdpowiedzSubscriptionWhereInput
  >;
}

export type PytanieWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OdpowiedzUpdateManyMutationInput {
  nrOdpowiedzi?: Maybe<Int>;
  odpowiedz?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UzytkownikPreviousValues {
  id: ID_Output;
  login: String;
  haslo: String;
  token: String;
}

export interface UzytkownikPreviousValuesPromise
  extends Promise<UzytkownikPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  login: () => Promise<String>;
  haslo: () => Promise<String>;
  token: () => Promise<String>;
}

export interface UzytkownikPreviousValuesSubscription
  extends Promise<AsyncIterator<UzytkownikPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  login: () => Promise<AsyncIterator<String>>;
  haslo: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface OdpowiedzEdge {
  node: Odpowiedz;
  cursor: String;
}

export interface OdpowiedzEdgePromise
  extends Promise<OdpowiedzEdge>,
    Fragmentable {
  node: <T = OdpowiedzPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OdpowiedzEdgeSubscription
  extends Promise<AsyncIterator<OdpowiedzEdge>>,
    Fragmentable {
  node: <T = OdpowiedzSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Pytanie {
  id: ID_Output;
  numerPytania: Int;
  trescPytnia: String;
  pytanieKontrolne: Boolean;
  reprezentacjaPytania: String;
}

export interface PytaniePromise extends Promise<Pytanie>, Fragmentable {
  id: () => Promise<ID_Output>;
  numerPytania: () => Promise<Int>;
  trescPytnia: () => Promise<String>;
  pytanieKontrolne: () => Promise<Boolean>;
  reprezentacjaPytania: () => Promise<String>;
  odpowiedzi: <T = FragmentableArray<Odpowiedz>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PytanieSubscription
  extends Promise<AsyncIterator<Pytanie>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numerPytania: () => Promise<AsyncIterator<Int>>;
  trescPytnia: () => Promise<AsyncIterator<String>>;
  pytanieKontrolne: () => Promise<AsyncIterator<Boolean>>;
  reprezentacjaPytania: () => Promise<AsyncIterator<String>>;
  odpowiedzi: <T = Promise<AsyncIterator<OdpowiedzSubscription>>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PytanieNullablePromise
  extends Promise<Pytanie | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numerPytania: () => Promise<Int>;
  trescPytnia: () => Promise<String>;
  pytanieKontrolne: () => Promise<Boolean>;
  reprezentacjaPytania: () => Promise<String>;
  odpowiedzi: <T = FragmentableArray<Odpowiedz>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OdpowiedzConnection {
  pageInfo: PageInfo;
  edges: OdpowiedzEdge[];
}

export interface OdpowiedzConnectionPromise
  extends Promise<OdpowiedzConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OdpowiedzEdge>>() => T;
  aggregate: <T = AggregateOdpowiedzPromise>() => T;
}

export interface OdpowiedzConnectionSubscription
  extends Promise<AsyncIterator<OdpowiedzConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OdpowiedzEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOdpowiedzSubscription>() => T;
}

export interface AggregateAnkieta {
  count: Int;
}

export interface AggregateAnkietaPromise
  extends Promise<AggregateAnkieta>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnkietaSubscription
  extends Promise<AsyncIterator<AggregateAnkieta>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUzytkownik {
  count: Int;
}

export interface AggregateUzytkownikPromise
  extends Promise<AggregateUzytkownik>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUzytkownikSubscription
  extends Promise<AsyncIterator<AggregateUzytkownik>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UzytkownikConnection {
  pageInfo: PageInfo;
  edges: UzytkownikEdge[];
}

export interface UzytkownikConnectionPromise
  extends Promise<UzytkownikConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UzytkownikEdge>>() => T;
  aggregate: <T = AggregateUzytkownikPromise>() => T;
}

export interface UzytkownikConnectionSubscription
  extends Promise<AsyncIterator<UzytkownikConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UzytkownikEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUzytkownikSubscription>() => T;
}

export interface AnkietaEdge {
  node: Ankieta;
  cursor: String;
}

export interface AnkietaEdgePromise extends Promise<AnkietaEdge>, Fragmentable {
  node: <T = AnkietaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnkietaEdgeSubscription
  extends Promise<AsyncIterator<AnkietaEdge>>,
    Fragmentable {
  node: <T = AnkietaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePytanie {
  count: Int;
}

export interface AggregatePytaniePromise
  extends Promise<AggregatePytanie>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePytanieSubscription
  extends Promise<AsyncIterator<AggregatePytanie>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PytanieConnection {
  pageInfo: PageInfo;
  edges: PytanieEdge[];
}

export interface PytanieConnectionPromise
  extends Promise<PytanieConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PytanieEdge>>() => T;
  aggregate: <T = AggregatePytaniePromise>() => T;
}

export interface PytanieConnectionSubscription
  extends Promise<AsyncIterator<PytanieConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PytanieEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePytanieSubscription>() => T;
}

export interface AnkietaConnection {
  pageInfo: PageInfo;
  edges: AnkietaEdge[];
}

export interface AnkietaConnectionPromise
  extends Promise<AnkietaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnkietaEdge>>() => T;
  aggregate: <T = AggregateAnkietaPromise>() => T;
}

export interface AnkietaConnectionSubscription
  extends Promise<AsyncIterator<AnkietaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnkietaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnkietaSubscription>() => T;
}

export interface OdpowiedziEdge {
  node: Odpowiedzi;
  cursor: String;
}

export interface OdpowiedziEdgePromise
  extends Promise<OdpowiedziEdge>,
    Fragmentable {
  node: <T = OdpowiedziPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OdpowiedziEdgeSubscription
  extends Promise<AsyncIterator<OdpowiedziEdge>>,
    Fragmentable {
  node: <T = OdpowiedziSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Ankieta {
  id: ID_Output;
  nazwaAnkiety: String;
  czasZakonczenia: DateTimeOutput;
}

export interface AnkietaPromise extends Promise<Ankieta>, Fragmentable {
  id: () => Promise<ID_Output>;
  nazwaAnkiety: () => Promise<String>;
  tworca: <T = UzytkownikPromise>() => T;
  czasZakonczenia: () => Promise<DateTimeOutput>;
  pytania: <T = FragmentableArray<Pytanie>>(args?: {
    where?: PytanieWhereInput;
    orderBy?: PytanieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnkietaSubscription
  extends Promise<AsyncIterator<Ankieta>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nazwaAnkiety: () => Promise<AsyncIterator<String>>;
  tworca: <T = UzytkownikSubscription>() => T;
  czasZakonczenia: () => Promise<AsyncIterator<DateTimeOutput>>;
  pytania: <T = Promise<AsyncIterator<PytanieSubscription>>>(args?: {
    where?: PytanieWhereInput;
    orderBy?: PytanieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnkietaNullablePromise
  extends Promise<Ankieta | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nazwaAnkiety: () => Promise<String>;
  tworca: <T = UzytkownikPromise>() => T;
  czasZakonczenia: () => Promise<DateTimeOutput>;
  pytania: <T = FragmentableArray<Pytanie>>(args?: {
    where?: PytanieWhereInput;
    orderBy?: PytanieOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PytaniePreviousValues {
  id: ID_Output;
  numerPytania: Int;
  trescPytnia: String;
  pytanieKontrolne: Boolean;
  reprezentacjaPytania: String;
}

export interface PytaniePreviousValuesPromise
  extends Promise<PytaniePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  numerPytania: () => Promise<Int>;
  trescPytnia: () => Promise<String>;
  pytanieKontrolne: () => Promise<Boolean>;
  reprezentacjaPytania: () => Promise<String>;
}

export interface PytaniePreviousValuesSubscription
  extends Promise<AsyncIterator<PytaniePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  numerPytania: () => Promise<AsyncIterator<Int>>;
  trescPytnia: () => Promise<AsyncIterator<String>>;
  pytanieKontrolne: () => Promise<AsyncIterator<Boolean>>;
  reprezentacjaPytania: () => Promise<AsyncIterator<String>>;
}

export interface AnkietaSubscriptionPayload {
  mutation: MutationType;
  node: Ankieta;
  updatedFields: String[];
  previousValues: AnkietaPreviousValues;
}

export interface AnkietaSubscriptionPayloadPromise
  extends Promise<AnkietaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnkietaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnkietaPreviousValuesPromise>() => T;
}

export interface AnkietaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnkietaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnkietaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnkietaPreviousValuesSubscription>() => T;
}

export interface Uzytkownik {
  id: ID_Output;
  login: String;
  haslo: String;
  token: String;
}

export interface UzytkownikPromise extends Promise<Uzytkownik>, Fragmentable {
  id: () => Promise<ID_Output>;
  login: () => Promise<String>;
  haslo: () => Promise<String>;
  token: () => Promise<String>;
}

export interface UzytkownikSubscription
  extends Promise<AsyncIterator<Uzytkownik>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  login: () => Promise<AsyncIterator<String>>;
  haslo: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface UzytkownikNullablePromise
  extends Promise<Uzytkownik | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  login: () => Promise<String>;
  haslo: () => Promise<String>;
  token: () => Promise<String>;
}

export interface AnkietaPreviousValues {
  id: ID_Output;
  nazwaAnkiety: String;
  czasZakonczenia: DateTimeOutput;
}

export interface AnkietaPreviousValuesPromise
  extends Promise<AnkietaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nazwaAnkiety: () => Promise<String>;
  czasZakonczenia: () => Promise<DateTimeOutput>;
}

export interface AnkietaPreviousValuesSubscription
  extends Promise<AsyncIterator<AnkietaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nazwaAnkiety: () => Promise<AsyncIterator<String>>;
  czasZakonczenia: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateOdpowiedz {
  count: Int;
}

export interface AggregateOdpowiedzPromise
  extends Promise<AggregateOdpowiedz>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOdpowiedzSubscription
  extends Promise<AsyncIterator<AggregateOdpowiedz>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PytanieSubscriptionPayload {
  mutation: MutationType;
  node: Pytanie;
  updatedFields: String[];
  previousValues: PytaniePreviousValues;
}

export interface PytanieSubscriptionPayloadPromise
  extends Promise<PytanieSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PytaniePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PytaniePreviousValuesPromise>() => T;
}

export interface PytanieSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PytanieSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PytanieSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PytaniePreviousValuesSubscription>() => T;
}

export interface UzytkownikSubscriptionPayload {
  mutation: MutationType;
  node: Uzytkownik;
  updatedFields: String[];
  previousValues: UzytkownikPreviousValues;
}

export interface UzytkownikSubscriptionPayloadPromise
  extends Promise<UzytkownikSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UzytkownikPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UzytkownikPreviousValuesPromise>() => T;
}

export interface UzytkownikSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UzytkownikSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UzytkownikSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UzytkownikPreviousValuesSubscription>() => T;
}

export interface OdpowiedzSubscriptionPayload {
  mutation: MutationType;
  node: Odpowiedz;
  updatedFields: String[];
  previousValues: OdpowiedzPreviousValues;
}

export interface OdpowiedzSubscriptionPayloadPromise
  extends Promise<OdpowiedzSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OdpowiedzPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OdpowiedzPreviousValuesPromise>() => T;
}

export interface OdpowiedzSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OdpowiedzSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OdpowiedzSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OdpowiedzPreviousValuesSubscription>() => T;
}

export interface AggregateOdpowiedzi {
  count: Int;
}

export interface AggregateOdpowiedziPromise
  extends Promise<AggregateOdpowiedzi>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOdpowiedziSubscription
  extends Promise<AsyncIterator<AggregateOdpowiedzi>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OdpowiedziConnection {
  pageInfo: PageInfo;
  edges: OdpowiedziEdge[];
}

export interface OdpowiedziConnectionPromise
  extends Promise<OdpowiedziConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OdpowiedziEdge>>() => T;
  aggregate: <T = AggregateOdpowiedziPromise>() => T;
}

export interface OdpowiedziConnectionSubscription
  extends Promise<AsyncIterator<OdpowiedziConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OdpowiedziEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOdpowiedziSubscription>() => T;
}

export interface OdpowiedziPreviousValues {
  id: ID_Output;
  idAnkiety: ID_Output;
  pseudonim: String;
}

export interface OdpowiedziPreviousValuesPromise
  extends Promise<OdpowiedziPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idAnkiety: () => Promise<ID_Output>;
  pseudonim: () => Promise<String>;
}

export interface OdpowiedziPreviousValuesSubscription
  extends Promise<AsyncIterator<OdpowiedziPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idAnkiety: () => Promise<AsyncIterator<ID_Output>>;
  pseudonim: () => Promise<AsyncIterator<String>>;
}

export interface OdpowiedziSubscriptionPayload {
  mutation: MutationType;
  node: Odpowiedzi;
  updatedFields: String[];
  previousValues: OdpowiedziPreviousValues;
}

export interface OdpowiedziSubscriptionPayloadPromise
  extends Promise<OdpowiedziSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OdpowiedziPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OdpowiedziPreviousValuesPromise>() => T;
}

export interface OdpowiedziSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OdpowiedziSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OdpowiedziSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OdpowiedziPreviousValuesSubscription>() => T;
}

export interface Odpowiedz {
  id: ID_Output;
  nrOdpowiedzi: Int;
  odpowiedz: String;
}

export interface OdpowiedzPromise extends Promise<Odpowiedz>, Fragmentable {
  id: () => Promise<ID_Output>;
  nrOdpowiedzi: () => Promise<Int>;
  odpowiedz: () => Promise<String>;
}

export interface OdpowiedzSubscription
  extends Promise<AsyncIterator<Odpowiedz>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nrOdpowiedzi: () => Promise<AsyncIterator<Int>>;
  odpowiedz: () => Promise<AsyncIterator<String>>;
}

export interface OdpowiedzNullablePromise
  extends Promise<Odpowiedz | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nrOdpowiedzi: () => Promise<Int>;
  odpowiedz: () => Promise<String>;
}

export interface OdpowiedzPreviousValues {
  id: ID_Output;
  nrOdpowiedzi: Int;
  odpowiedz: String;
}

export interface OdpowiedzPreviousValuesPromise
  extends Promise<OdpowiedzPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nrOdpowiedzi: () => Promise<Int>;
  odpowiedz: () => Promise<String>;
}

export interface OdpowiedzPreviousValuesSubscription
  extends Promise<AsyncIterator<OdpowiedzPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nrOdpowiedzi: () => Promise<AsyncIterator<Int>>;
  odpowiedz: () => Promise<AsyncIterator<String>>;
}

export interface Odpowiedzi {
  id: ID_Output;
  idAnkiety: ID_Output;
  pseudonim: String;
}

export interface OdpowiedziPromise extends Promise<Odpowiedzi>, Fragmentable {
  id: () => Promise<ID_Output>;
  idAnkiety: () => Promise<ID_Output>;
  pseudonim: () => Promise<String>;
  odpowiedzi: <T = FragmentableArray<Odpowiedz>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OdpowiedziSubscription
  extends Promise<AsyncIterator<Odpowiedzi>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idAnkiety: () => Promise<AsyncIterator<ID_Output>>;
  pseudonim: () => Promise<AsyncIterator<String>>;
  odpowiedzi: <T = Promise<AsyncIterator<OdpowiedzSubscription>>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OdpowiedziNullablePromise
  extends Promise<Odpowiedzi | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idAnkiety: () => Promise<ID_Output>;
  pseudonim: () => Promise<String>;
  odpowiedzi: <T = FragmentableArray<Odpowiedz>>(args?: {
    where?: OdpowiedzWhereInput;
    orderBy?: OdpowiedzOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PytanieEdge {
  node: Pytanie;
  cursor: String;
}

export interface PytanieEdgePromise extends Promise<PytanieEdge>, Fragmentable {
  node: <T = PytaniePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PytanieEdgeSubscription
  extends Promise<AsyncIterator<PytanieEdge>>,
    Fragmentable {
  node: <T = PytanieSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UzytkownikEdge {
  node: Uzytkownik;
  cursor: String;
}

export interface UzytkownikEdgePromise
  extends Promise<UzytkownikEdge>,
    Fragmentable {
  node: <T = UzytkownikPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UzytkownikEdgeSubscription
  extends Promise<AsyncIterator<UzytkownikEdge>>,
    Fragmentable {
  node: <T = UzytkownikSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Odpowiedz",
    embedded: false
  },
  {
    name: "Pytanie",
    embedded: false
  },
  {
    name: "Uzytkownik",
    embedded: false
  },
  {
    name: "Ankieta",
    embedded: false
  },
  {
    name: "Odpowiedzi",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
